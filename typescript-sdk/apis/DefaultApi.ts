/* tslint:disable */
/* eslint-disable */
/**
 * Crestal dashboard API - /crestal - OpenAPI 3.0
 * This is a crestal-dashboard-backend server.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  APIKey,
  Chat,
  ChatRequest,
  CommonResponse,
  DA,
  DAInfoResource,
  Deployment,
  Deployments,
  GetNonce200Response,
  GraphDAInfoResponse,
  ListDAInfoResponse,
  LoginRequest,
  LoginResponse,
  PostResponse,
  ProjectResource,
  ProjectUpdate,
  Projects,
  Proposal,
  Quests,
  Referral,
  Score,
  Solver,
  SolverProposals,
  SolversProposals,
  SolversProposalsResponse,
  Token,
  User,
  UserPostQuests,
  UserQuest,
  WeeklyQuests,
  WhiteList,
  Worker,
} from '../models/index';
import {
    APIKeyFromJSON,
    APIKeyToJSON,
    ChatFromJSON,
    ChatToJSON,
    ChatRequestFromJSON,
    ChatRequestToJSON,
    CommonResponseFromJSON,
    CommonResponseToJSON,
    DAFromJSON,
    DAToJSON,
    DAInfoResourceFromJSON,
    DAInfoResourceToJSON,
    DeploymentFromJSON,
    DeploymentToJSON,
    DeploymentsFromJSON,
    DeploymentsToJSON,
    GetNonce200ResponseFromJSON,
    GetNonce200ResponseToJSON,
    GraphDAInfoResponseFromJSON,
    GraphDAInfoResponseToJSON,
    ListDAInfoResponseFromJSON,
    ListDAInfoResponseToJSON,
    LoginRequestFromJSON,
    LoginRequestToJSON,
    LoginResponseFromJSON,
    LoginResponseToJSON,
    PostResponseFromJSON,
    PostResponseToJSON,
    ProjectResourceFromJSON,
    ProjectResourceToJSON,
    ProjectUpdateFromJSON,
    ProjectUpdateToJSON,
    ProjectsFromJSON,
    ProjectsToJSON,
    ProposalFromJSON,
    ProposalToJSON,
    QuestsFromJSON,
    QuestsToJSON,
    ReferralFromJSON,
    ReferralToJSON,
    ScoreFromJSON,
    ScoreToJSON,
    SolverFromJSON,
    SolverToJSON,
    SolverProposalsFromJSON,
    SolverProposalsToJSON,
    SolversProposalsFromJSON,
    SolversProposalsToJSON,
    SolversProposalsResponseFromJSON,
    SolversProposalsResponseToJSON,
    TokenFromJSON,
    TokenToJSON,
    UserFromJSON,
    UserToJSON,
    UserPostQuestsFromJSON,
    UserPostQuestsToJSON,
    UserQuestFromJSON,
    UserQuestToJSON,
    WeeklyQuestsFromJSON,
    WeeklyQuestsToJSON,
    WhiteListFromJSON,
    WhiteListToJSON,
    WorkerFromJSON,
    WorkerToJSON,
} from '../models/index';

export interface APIKeyRequest {
    userAddress: string;
}

export interface AcceptSolverProposalsRequest {
    loginRequest: LoginRequest;
}

export interface ClaimReferCodeRequest {
    code: string;
    isClaimed?: boolean;
}

export interface CreateAPIKeyRequest {
    loginRequest: LoginRequest;
}

export interface CreateDARequest {
    dA: DA;
}

export interface CreateQuestsRequest {
    quests: Quests;
}

export interface CreateSolverRequest {
    solver: Solver;
}

export interface CreateWorkerDeploymentRequest {
    loginRequest: LoginRequest;
}

export interface DeploymentPostRequest {
    deployment: Deployment;
}

export interface GetChatRequest {
    projectId: string;
}

export interface GetDAsRequest {
    name: GetDAsNameEnum;
    networkType?: GetDAsNetworkTypeEnum;
}

export interface GetDAsTemporaryRequest {
    name: GetDAsTemporaryNameEnum;
    networkType?: GetDAsTemporaryNetworkTypeEnum;
}

export interface GetDeploymentByIdRequest {
    deploymentId: number;
}

export interface GetDeploymentsRequest {
    userAddress?: string;
    proposalId?: number;
    proposalHash?: string;
}

export interface GetNonceRequest {
    userAddress: string;
}

export interface GetProjectStatusRequest {
    userAddress?: string;
    proposalId?: number;
    deploymentId?: number;
}

export interface GetProjectStatusByIdRequest {
    projectId: string;
}

export interface GetProposalByIDRequest {
    proposalId: number;
}

export interface GetRecommendProposalsRequest {
    sla: number;
    cost: number;
    throughput: number;
    errorRate: number;
}

export interface GetScoresRequest {
    topK?: number;
}

export interface GetSolverByUUIDRequest {
    solverUuid: string;
}

export interface GetSolversProposalsRequest {
    requestId: string;
}

export interface GetUserInfoRequest {
    userAddress: string;
}

export interface GetWorkerByUUIDRequest {
    workerUuid: string;
}

export interface GetWorkerDeploymentsRequest {
    requestId: string;
}

export interface GraphDAInfoEndPointRequest {
    fromTime: number;
    toTime: number;
    networkType: GraphDAInfoEndPointNetworkTypeEnum;
    daList: Array<GraphDAInfoEndPointDaListEnum>;
}

export interface ImportUserQuestsRequest {
    userPostQuests: UserPostQuests;
}

export interface InteractRequest {
    userAddress?: string;
    type?: InteractTypeEnum;
}

export interface ListDAInfoRequest {
    name: ListDAInfoNameEnum;
    networkType: ListDAInfoNetworkTypeEnum;
}

export interface LoginOperationRequest {
    loginRequest: LoginRequest;
}

export interface ProjectCancelledRequest {
    projectId: string;
}

export interface ProjectPatchRequest {
    projectId: string;
    projectUpdate: ProjectUpdate;
}

export interface ProjectPostRequest {
    projectUpdate: ProjectUpdate;
}

export interface ProjectStopRequest {
    projectId: string;
}

export interface RefreshTokenRequest {
    userAddress: string;
}

export interface SendChatRequest {
    chatRequest: ChatRequest;
}

export interface SetDAInfoRequest {
    data: DAInfoResource;
}

export interface SetNodeDAInfoRequest {
    loginRequest: LoginRequest;
}

export interface SetProposalRequest {
    proposal: Proposal;
}

export interface SetWhiteListRequest {
    whiteList: WhiteList;
}

export interface UpdateQuestsRequest {
    questId: number;
    quests: Quests;
}

export interface UpdateWorkerDeploymentRequest {
    loginRequest: LoginRequest;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Provides an API key associated with the specified user address.
     * Retrieve an API key
     */
    async aPIKeyRaw(requestParameters: APIKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<APIKey>> {
        if (requestParameters['userAddress'] == null) {
            throw new runtime.RequiredError(
                'userAddress',
                'Required parameter "userAddress" was null or undefined when calling aPIKey().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['userAddress'] != null) {
            queryParameters['user_address'] = requestParameters['userAddress'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api_key`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => APIKeyFromJSON(jsonValue));
    }

    /**
     * Provides an API key associated with the specified user address.
     * Retrieve an API key
     */
    async aPIKey(requestParameters: APIKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<APIKey> {
        const response = await this.aPIKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Accepts a list of proposals from solvers for processing.
     * Accept a list of proposals from solvers
     */
    async acceptSolverProposalsRaw(requestParameters: AcceptSolverProposalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SolversProposals>> {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError(
                'loginRequest',
                'Required parameter "loginRequest" was null or undefined when calling acceptSolverProposals().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/proposals/solver`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SolversProposalsFromJSON(jsonValue));
    }

    /**
     * Accepts a list of proposals from solvers for processing.
     * Accept a list of proposals from solvers
     */
    async acceptSolverProposals(requestParameters: AcceptSolverProposalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SolversProposals> {
        const response = await this.acceptSolverProposalsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Claims a specific referral code.
     * Claim a referral code
     */
    async claimReferCodeRaw(requestParameters: ClaimReferCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommonResponse>> {
        if (requestParameters['code'] == null) {
            throw new runtime.RequiredError(
                'code',
                'Required parameter "code" was null or undefined when calling claimReferCode().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['isClaimed'] != null) {
            queryParameters['is_claimed'] = requestParameters['isClaimed'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/referral/{code}/claim`.replace(`{${"code"}}`, encodeURIComponent(String(requestParameters['code']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommonResponseFromJSON(jsonValue));
    }

    /**
     * Claims a specific referral code.
     * Claim a referral code
     */
    async claimReferCode(requestParameters: ClaimReferCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommonResponse> {
        const response = await this.claimReferCodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generates a new API key for the specified user.
     * Create a new API key
     */
    async createAPIKeyRaw(requestParameters: CreateAPIKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<APIKey>> {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError(
                'loginRequest',
                'Required parameter "loginRequest" was null or undefined when calling createAPIKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api_key`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => APIKeyFromJSON(jsonValue));
    }

    /**
     * Generates a new API key for the specified user.
     * Create a new API key
     */
    async createAPIKey(requestParameters: CreateAPIKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<APIKey> {
        const response = await this.createAPIKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Onboards a new Data Availability (DA) solution, including static information such as consensus algorithm.
     * Create a new DA entry in the database
     */
    async createDARaw(requestParameters: CreateDARequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DA>> {
        if (requestParameters['dA'] == null) {
            throw new runtime.RequiredError(
                'dA',
                'Required parameter "dA" was null or undefined when calling createDA().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/onboarding/da`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DAToJSON(requestParameters['dA']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DAFromJSON(jsonValue));
    }

    /**
     * Onboards a new Data Availability (DA) solution, including static information such as consensus algorithm.
     * Create a new DA entry in the database
     */
    async createDA(requestParameters: CreateDARequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DA> {
        const response = await this.createDARaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds a new quest to the system.
     * Create a new quest
     */
    async createQuestsRaw(requestParameters: CreateQuestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Quests>> {
        if (requestParameters['quests'] == null) {
            throw new runtime.RequiredError(
                'quests',
                'Required parameter "quests" was null or undefined when calling createQuests().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/quests`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QuestsToJSON(requestParameters['quests']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestsFromJSON(jsonValue));
    }

    /**
     * Adds a new quest to the system.
     * Create a new quest
     */
    async createQuests(requestParameters: CreateQuestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Quests> {
        const response = await this.createQuestsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds a new solver with provided details.
     * Create a solver
     */
    async createSolverRaw(requestParameters: CreateSolverRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Solver>> {
        if (requestParameters['solver'] == null) {
            throw new runtime.RequiredError(
                'solver',
                'Required parameter "solver" was null or undefined when calling createSolver().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/solvers`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SolverToJSON(requestParameters['solver']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SolverFromJSON(jsonValue));
    }

    /**
     * Adds a new solver with provided details.
     * Create a solver
     */
    async createSolver(requestParameters: CreateSolverRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Solver> {
        const response = await this.createSolverRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates deployment information for a specific worker.
     * Create worker deployment information
     */
    async createWorkerDeploymentRaw(requestParameters: CreateWorkerDeploymentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Deployment>> {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError(
                'loginRequest',
                'Required parameter "loginRequest" was null or undefined when calling createWorkerDeployment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/deployments/worker`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeploymentFromJSON(jsonValue));
    }

    /**
     * Creates deployment information for a specific worker.
     * Create worker deployment information
     */
    async createWorkerDeployment(requestParameters: CreateWorkerDeploymentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Deployment> {
        const response = await this.createWorkerDeploymentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates new deployment information for a specified user or proposal.
     * Create deployment information
     */
    async deploymentPostRaw(requestParameters: DeploymentPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Deployment>> {
        if (requestParameters['deployment'] == null) {
            throw new runtime.RequiredError(
                'deployment',
                'Required parameter "deployment" was null or undefined when calling deploymentPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/deployments`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DeploymentToJSON(requestParameters['deployment']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeploymentFromJSON(jsonValue));
    }

    /**
     * Creates new deployment information for a specified user or proposal.
     * Create deployment information
     */
    async deploymentPost(requestParameters: DeploymentPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Deployment> {
        const response = await this.deploymentPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the chat history associated with a specified project.
     * Retrieve chat history
     */
    async getChatRaw(requestParameters: GetChatRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Chat>>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling getChat().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['projectId'] != null) {
            queryParameters['project_id'] = requestParameters['projectId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/chat`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ChatFromJSON));
    }

    /**
     * Retrieves the chat history associated with a specified project.
     * Retrieve chat history
     */
    async getChat(requestParameters: GetChatRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Chat>> {
        const response = await this.getChatRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides static information for specified Data Availability (DA) solutions.
     * Retrieve DA static information
     */
    async getDAsRaw(requestParameters: GetDAsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DA>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getDAs().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['networkType'] != null) {
            queryParameters['network_type'] = requestParameters['networkType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/info/da/static`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DAFromJSON(jsonValue));
    }

    /**
     * Provides static information for specified Data Availability (DA) solutions.
     * Retrieve DA static information
     */
    async getDAs(requestParameters: GetDAsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DA> {
        const response = await this.getDAsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides static information about a specific Data Availability (DA) solution. This endpoint is temporary and will be removed later.
     * Retrieve DA static information (temporary endpoint)
     */
    async getDAsTemporaryRaw(requestParameters: GetDAsTemporaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DA>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getDAsTemporary().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['networkType'] != null) {
            queryParameters['network_type'] = requestParameters['networkType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/das`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DAFromJSON(jsonValue));
    }

    /**
     * Provides static information about a specific Data Availability (DA) solution. This endpoint is temporary and will be removed later.
     * Retrieve DA static information (temporary endpoint)
     */
    async getDAsTemporary(requestParameters: GetDAsTemporaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DA> {
        const response = await this.getDAsTemporaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches detailed information about a deployment by its unique identifier.
     * Retrieve deployment information
     */
    async getDeploymentByIdRaw(requestParameters: GetDeploymentByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Deployment>> {
        if (requestParameters['deploymentId'] == null) {
            throw new runtime.RequiredError(
                'deploymentId',
                'Required parameter "deploymentId" was null or undefined when calling getDeploymentById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/deployments/{deployment_id}`.replace(`{${"deployment_id"}}`, encodeURIComponent(String(requestParameters['deploymentId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeploymentFromJSON(jsonValue));
    }

    /**
     * Fetches detailed information about a deployment by its unique identifier.
     * Retrieve deployment information
     */
    async getDeploymentById(requestParameters: GetDeploymentByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Deployment> {
        const response = await this.getDeploymentByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides a list of all deployment information associated with the user\'s address, proposal ID, or hash.
     * Retrieve deployments based on various parameters
     */
    async getDeploymentsRaw(requestParameters: GetDeploymentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Deployments>> {
        const queryParameters: any = {};

        if (requestParameters['userAddress'] != null) {
            queryParameters['user_address'] = requestParameters['userAddress'];
        }

        if (requestParameters['proposalId'] != null) {
            queryParameters['proposal_id'] = requestParameters['proposalId'];
        }

        if (requestParameters['proposalHash'] != null) {
            queryParameters['proposal_hash'] = requestParameters['proposalHash'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/deployments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeploymentsFromJSON(jsonValue));
    }

    /**
     * Provides a list of all deployment information associated with the user\'s address, proposal ID, or hash.
     * Retrieve deployments based on various parameters
     */
    async getDeployments(requestParameters: GetDeploymentsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Deployments> {
        const response = await this.getDeploymentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides a nonce for authentication purposes..
     * Retrieve nonce for authentication
     */
    async getNonceRaw(requestParameters: GetNonceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNonce200Response>> {
        if (requestParameters['userAddress'] == null) {
            throw new runtime.RequiredError(
                'userAddress',
                'Required parameter "userAddress" was null or undefined when calling getNonce().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['userAddress'] != null) {
            queryParameters['user_address'] = requestParameters['userAddress'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/nonce`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNonce200ResponseFromJSON(jsonValue));
    }

    /**
     * Provides a nonce for authentication purposes..
     * Retrieve nonce for authentication
     */
    async getNonce(requestParameters: GetNonceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNonce200Response> {
        const response = await this.getNonceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides detailed information about the projects associated with the user\'s address.
     * Retrieve a list of user projects
     */
    async getProjectStatusRaw(requestParameters: GetProjectStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Projects>> {
        const queryParameters: any = {};

        if (requestParameters['userAddress'] != null) {
            queryParameters['user_address'] = requestParameters['userAddress'];
        }

        if (requestParameters['proposalId'] != null) {
            queryParameters['proposal_id'] = requestParameters['proposalId'];
        }

        if (requestParameters['deploymentId'] != null) {
            queryParameters['deployment_id'] = requestParameters['deploymentId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectsFromJSON(jsonValue));
    }

    /**
     * Provides detailed information about the projects associated with the user\'s address.
     * Retrieve a list of user projects
     */
    async getProjectStatus(requestParameters: GetProjectStatusRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Projects> {
        const response = await this.getProjectStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches detailed information about the specified project.
     * Retrieve project information
     */
    async getProjectStatusByIdRaw(requestParameters: GetProjectStatusByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProjectResource>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling getProjectStatusById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{project_id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectResourceFromJSON(jsonValue));
    }

    /**
     * Fetches detailed information about the specified project.
     * Retrieve project information
     */
    async getProjectStatusById(requestParameters: GetProjectStatusByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProjectResource> {
        const response = await this.getProjectStatusByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides detailed information about a proposal by its unique identifier.
     * Retrieve a proposal by ID
     */
    async getProposalByIDRaw(requestParameters: GetProposalByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Proposal>> {
        if (requestParameters['proposalId'] == null) {
            throw new runtime.RequiredError(
                'proposalId',
                'Required parameter "proposalId" was null or undefined when calling getProposalByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/proposals/{proposal_id}`.replace(`{${"proposal_id"}}`, encodeURIComponent(String(requestParameters['proposalId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProposalFromJSON(jsonValue));
    }

    /**
     * Provides detailed information about a proposal by its unique identifier.
     * Retrieve a proposal by ID
     */
    async getProposalByID(requestParameters: GetProposalByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Proposal> {
        const response = await this.getProposalByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides a list of all quests available to the user.
     * Retrieve all quests
     */
    async getQuestsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Quests>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/quests`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(QuestsFromJSON));
    }

    /**
     * Provides a list of all quests available to the user.
     * Retrieve all quests
     */
    async getQuests(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Quests>> {
        const response = await this.getQuestsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Provides a list of proposals recommended by solvers. The list is sorted by default.
     * Retrieve recommended proposals from solvers
     */
    async getRecommendProposalsRaw(requestParameters: GetRecommendProposalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SolverProposals>> {
        if (requestParameters['sla'] == null) {
            throw new runtime.RequiredError(
                'sla',
                'Required parameter "sla" was null or undefined when calling getRecommendProposals().'
            );
        }

        if (requestParameters['cost'] == null) {
            throw new runtime.RequiredError(
                'cost',
                'Required parameter "cost" was null or undefined when calling getRecommendProposals().'
            );
        }

        if (requestParameters['throughput'] == null) {
            throw new runtime.RequiredError(
                'throughput',
                'Required parameter "throughput" was null or undefined when calling getRecommendProposals().'
            );
        }

        if (requestParameters['errorRate'] == null) {
            throw new runtime.RequiredError(
                'errorRate',
                'Required parameter "errorRate" was null or undefined when calling getRecommendProposals().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['sla'] != null) {
            queryParameters['sla'] = requestParameters['sla'];
        }

        if (requestParameters['cost'] != null) {
            queryParameters['cost'] = requestParameters['cost'];
        }

        if (requestParameters['throughput'] != null) {
            queryParameters['throughput'] = requestParameters['throughput'];
        }

        if (requestParameters['errorRate'] != null) {
            queryParameters['error_rate'] = requestParameters['errorRate'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/proposals/recommendation`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SolverProposalsFromJSON(jsonValue));
    }

    /**
     * Provides a list of proposals recommended by solvers. The list is sorted by default.
     * Retrieve recommended proposals from solvers
     */
    async getRecommendProposals(requestParameters: GetRecommendProposalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SolverProposals> {
        const response = await this.getRecommendProposalsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the top scores for a specified number of users.
     * Retrieve top user scores
     */
    async getScoresRaw(requestParameters: GetScoresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Score>>> {
        const queryParameters: any = {};

        if (requestParameters['topK'] != null) {
            queryParameters['top_k'] = requestParameters['topK'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/scores`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ScoreFromJSON));
    }

    /**
     * Retrieves the top scores for a specified number of users.
     * Retrieve top user scores
     */
    async getScores(requestParameters: GetScoresRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Score>> {
        const response = await this.getScoresRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides information for a solver identified by a UUID.
     * Retrieve solver details by UUID
     */
    async getSolverByUUIDRaw(requestParameters: GetSolverByUUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Solver>> {
        if (requestParameters['solverUuid'] == null) {
            throw new runtime.RequiredError(
                'solverUuid',
                'Required parameter "solverUuid" was null or undefined when calling getSolverByUUID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/solvers/{solver_uuid}`.replace(`{${"solver_uuid"}}`, encodeURIComponent(String(requestParameters['solverUuid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SolverFromJSON(jsonValue));
    }

    /**
     * Provides information for a solver identified by a UUID.
     * Retrieve solver details by UUID
     */
    async getSolverByUUID(requestParameters: GetSolverByUUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Solver> {
        const response = await this.getSolverByUUIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides recommended proposals generated by solvers.
     * Retrieve recommended proposals from solvers
     */
    async getSolversProposalsRaw(requestParameters: GetSolversProposalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SolversProposalsResponse>> {
        if (requestParameters['requestId'] == null) {
            throw new runtime.RequiredError(
                'requestId',
                'Required parameter "requestId" was null or undefined when calling getSolversProposals().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['requestId'] != null) {
            queryParameters['request_id'] = requestParameters['requestId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/proposals/solver`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SolversProposalsResponseFromJSON(jsonValue));
    }

    /**
     * Provides recommended proposals generated by solvers.
     * Retrieve recommended proposals from solvers
     */
    async getSolversProposals(requestParameters: GetSolversProposalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SolversProposalsResponse> {
        const response = await this.getSolversProposalsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches information for a specific user by their blockchain address.
     * Retrieve user information
     */
    async getUserInfoRaw(requestParameters: GetUserInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<User>> {
        if (requestParameters['userAddress'] == null) {
            throw new runtime.RequiredError(
                'userAddress',
                'Required parameter "userAddress" was null or undefined when calling getUserInfo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/users/{user_address}`.replace(`{${"user_address"}}`, encodeURIComponent(String(requestParameters['userAddress']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * Fetches information for a specific user by their blockchain address.
     * Retrieve user information
     */
    async getUserInfo(requestParameters: GetUserInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<User> {
        const response = await this.getUserInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides a list of all quests associated with a user.
     * Retrieve all user quests
     */
    async getUserQuestsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserQuest>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/user/quests`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserQuestFromJSON));
    }

    /**
     * Provides a list of all quests associated with a user.
     * Retrieve all user quests
     */
    async getUserQuests(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserQuest>> {
        const response = await this.getUserQuestsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves referral details for the user, including the referral code, creation time, and claim status.
     * Retrieve user referral information
     */
    async getUserReferralRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Referral>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/referral`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ReferralFromJSON));
    }

    /**
     * Retrieves referral details for the user, including the referral code, creation time, and claim status.
     * Retrieve user referral information
     */
    async getUserReferral(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Referral>> {
        const response = await this.getUserReferralRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of weekly quests available for all users.
     * Retrieve weekly quests for all users
     */
    async getWeeklyQuestsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WeeklyQuests>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/quests/weekly`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WeeklyQuestsFromJSON(jsonValue));
    }

    /**
     * Retrieves a list of weekly quests available for all users.
     * Retrieve weekly quests for all users
     */
    async getWeeklyQuests(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WeeklyQuests> {
        const response = await this.getWeeklyQuestsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Provides a list of all wallet addresses that have been whitelisted.
     * Retrieve all whitelisted wallet addresses
     */
    async getWhiteListsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<WhiteList>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/whitelist`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WhiteListFromJSON));
    }

    /**
     * Provides a list of all wallet addresses that have been whitelisted.
     * Retrieve all whitelisted wallet addresses
     */
    async getWhiteLists(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<WhiteList>> {
        const response = await this.getWhiteListsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Provides information for a worker identified by a UUID.
     * Retrieve worker details by UUID
     */
    async getWorkerByUUIDRaw(requestParameters: GetWorkerByUUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Worker>> {
        if (requestParameters['workerUuid'] == null) {
            throw new runtime.RequiredError(
                'workerUuid',
                'Required parameter "workerUuid" was null or undefined when calling getWorkerByUUID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/workers/{worker_uuid}`.replace(`{${"worker_uuid"}}`, encodeURIComponent(String(requestParameters['workerUuid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkerFromJSON(jsonValue));
    }

    /**
     * Provides information for a worker identified by a UUID.
     * Retrieve worker details by UUID
     */
    async getWorkerByUUID(requestParameters: GetWorkerByUUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Worker> {
        const response = await this.getWorkerByUUIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides deployment information associated with a specific request ID.
     * Retrieve worker deployments by request ID
     */
    async getWorkerDeploymentsRaw(requestParameters: GetWorkerDeploymentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Deployment>> {
        if (requestParameters['requestId'] == null) {
            throw new runtime.RequiredError(
                'requestId',
                'Required parameter "requestId" was null or undefined when calling getWorkerDeployments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['requestId'] != null) {
            queryParameters['request_id'] = requestParameters['requestId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/deployments/worker`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeploymentFromJSON(jsonValue));
    }

    /**
     * Provides deployment information associated with a specific request ID.
     * Retrieve worker deployments by request ID
     */
    async getWorkerDeployments(requestParameters: GetWorkerDeploymentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Deployment> {
        const response = await this.getWorkerDeploymentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides a list of all workers.
     * Retrieve a list of workers
     */
    async getWorkersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Worker>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/workers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkerFromJSON));
    }

    /**
     * Provides a list of all workers.
     * Retrieve a list of workers
     */
    async getWorkers(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Worker>> {
        const response = await this.getWorkersRaw(initOverrides);
        return await response.value();
    }

    /**
     * Provides a list of graph data for Data Availability (DA) solutions, including metrics such as latency and average cost.
     * Retrieve DA graph information
     */
    async graphDAInfoEndPointRaw(requestParameters: GraphDAInfoEndPointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GraphDAInfoResponse>> {
        if (requestParameters['fromTime'] == null) {
            throw new runtime.RequiredError(
                'fromTime',
                'Required parameter "fromTime" was null or undefined when calling graphDAInfoEndPoint().'
            );
        }

        if (requestParameters['toTime'] == null) {
            throw new runtime.RequiredError(
                'toTime',
                'Required parameter "toTime" was null or undefined when calling graphDAInfoEndPoint().'
            );
        }

        if (requestParameters['networkType'] == null) {
            throw new runtime.RequiredError(
                'networkType',
                'Required parameter "networkType" was null or undefined when calling graphDAInfoEndPoint().'
            );
        }

        if (requestParameters['daList'] == null) {
            throw new runtime.RequiredError(
                'daList',
                'Required parameter "daList" was null or undefined when calling graphDAInfoEndPoint().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fromTime'] != null) {
            queryParameters['from_time'] = requestParameters['fromTime'];
        }

        if (requestParameters['toTime'] != null) {
            queryParameters['to_time'] = requestParameters['toTime'];
        }

        if (requestParameters['networkType'] != null) {
            queryParameters['network_type'] = requestParameters['networkType'];
        }

        if (requestParameters['daList'] != null) {
            queryParameters['da_list'] = requestParameters['daList']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/info/da/graph`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GraphDAInfoResponseFromJSON(jsonValue));
    }

    /**
     * Provides a list of graph data for Data Availability (DA) solutions, including metrics such as latency and average cost.
     * Retrieve DA graph information
     */
    async graphDAInfoEndPoint(requestParameters: GraphDAInfoEndPointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GraphDAInfoResponse> {
        const response = await this.graphDAInfoEndPointRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async healthCheckGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/health_check`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async healthCheckGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.healthCheckGetRaw(initOverrides);
    }

    /**
     * Imports completed quests for a specific user.
     * Import user completed quests
     */
    async importUserQuestsRaw(requestParameters: ImportUserQuestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommonResponse>> {
        if (requestParameters['userPostQuests'] == null) {
            throw new runtime.RequiredError(
                'userPostQuests',
                'Required parameter "userPostQuests" was null or undefined when calling importUserQuests().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/quests`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserPostQuestsToJSON(requestParameters['userPostQuests']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommonResponseFromJSON(jsonValue));
    }

    /**
     * Imports completed quests for a specific user.
     * Import user completed quests
     */
    async importUserQuests(requestParameters: ImportUserQuestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommonResponse> {
        const response = await this.importUserQuestsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Submit a report detailing interactions with the dashboard.
     * Submit interaction report
     */
    async interactRaw(requestParameters: InteractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['userAddress'] != null) {
            queryParameters['user_address'] = requestParameters['userAddress'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/report`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Submit a report detailing interactions with the dashboard.
     * Submit interaction report
     */
    async interact(requestParameters: InteractRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.interactRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves a list of dynamic data for specified Data Availability (DA) solutions.
     * List Data Availability (DA) dynamic data
     */
    async listDAInfoRaw(requestParameters: ListDAInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListDAInfoResponse>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling listDAInfo().'
            );
        }

        if (requestParameters['networkType'] == null) {
            throw new runtime.RequiredError(
                'networkType',
                'Required parameter "networkType" was null or undefined when calling listDAInfo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['networkType'] != null) {
            queryParameters['network_type'] = requestParameters['networkType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/info/da`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListDAInfoResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a list of dynamic data for specified Data Availability (DA) solutions.
     * List Data Availability (DA) dynamic data
     */
    async listDAInfo(requestParameters: ListDAInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListDAInfoResponse> {
        const response = await this.listDAInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Authenticates the user and sets a session cookie.
     * Authenticate and obtain session cookie
     */
    async loginRaw(requestParameters: LoginOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoginResponse>> {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError(
                'loginRequest',
                'Required parameter "loginRequest" was null or undefined when calling login().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/login`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoginResponseFromJSON(jsonValue));
    }

    /**
     * Authenticates the user and sets a session cookie.
     * Authenticate and obtain session cookie
     */
    async login(requestParameters: LoginOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoginResponse> {
        const response = await this.loginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the status of the specified project to \"cancelled.\"
     * Cancel a project
     */
    async projectCancelledRaw(requestParameters: ProjectCancelledRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProjectResource>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling projectCancelled().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{project_id}/cancelled`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectResourceFromJSON(jsonValue));
    }

    /**
     * Updates the status of the specified project to \"cancelled.\"
     * Cancel a project
     */
    async projectCancelled(requestParameters: ProjectCancelledRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProjectResource> {
        const response = await this.projectCancelledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the details of a specified project, primarily used to track user activity.
     * Update project information
     */
    async projectPatchRaw(requestParameters: ProjectPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProjectResource>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling projectPatch().'
            );
        }

        if (requestParameters['projectUpdate'] == null) {
            throw new runtime.RequiredError(
                'projectUpdate',
                'Required parameter "projectUpdate" was null or undefined when calling projectPatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{project_id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectUpdateToJSON(requestParameters['projectUpdate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectResourceFromJSON(jsonValue));
    }

    /**
     * Updates the details of a specified project, primarily used to track user activity.
     * Update project information
     */
    async projectPatch(requestParameters: ProjectPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProjectResource> {
        const response = await this.projectPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates new project information, primarily used to track user activity in the frontend.
     * Create new project information
     */
    async projectPostRaw(requestParameters: ProjectPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProjectResource>> {
        if (requestParameters['projectUpdate'] == null) {
            throw new runtime.RequiredError(
                'projectUpdate',
                'Required parameter "projectUpdate" was null or undefined when calling projectPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectUpdateToJSON(requestParameters['projectUpdate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectResourceFromJSON(jsonValue));
    }

    /**
     * Creates new project information, primarily used to track user activity in the frontend.
     * Create new project information
     */
    async projectPost(requestParameters: ProjectPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProjectResource> {
        const response = await this.projectPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the status of the specified project to \"terminated.\"
     * Terminate a project
     */
    async projectStopRaw(requestParameters: ProjectStopRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProjectResource>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling projectStop().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{project_id}/stop`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectResourceFromJSON(jsonValue));
    }

    /**
     * Updates the status of the specified project to \"terminated.\"
     * Terminate a project
     */
    async projectStop(requestParameters: ProjectStopRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProjectResource> {
        const response = await this.projectStopRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides a new authentication token for the user.
     * Refresh authentication token
     */
    async refreshTokenRaw(requestParameters: RefreshTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Token>> {
        if (requestParameters['userAddress'] == null) {
            throw new runtime.RequiredError(
                'userAddress',
                'Required parameter "userAddress" was null or undefined when calling refreshToken().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['userAddress'] != null) {
            queryParameters['user_address'] = requestParameters['userAddress'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/token`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
    }

    /**
     * Provides a new authentication token for the user.
     * Refresh authentication token
     */
    async refreshToken(requestParameters: RefreshTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Token> {
        const response = await this.refreshTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends a chat message to the chat server.
     * Send a chat message
     */
    async sendChatRaw(requestParameters: SendChatRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Chat>> {
        if (requestParameters['chatRequest'] == null) {
            throw new runtime.RequiredError(
                'chatRequest',
                'Required parameter "chatRequest" was null or undefined when calling sendChat().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/chat`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ChatRequestToJSON(requestParameters['chatRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatFromJSON(jsonValue));
    }

    /**
     * Sends a chat message to the chat server.
     * Send a chat message
     */
    async sendChat(requestParameters: SendChatRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Chat> {
        const response = await this.sendChatRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates dynamic data for a specified Data Availability (DA) solution, including metrics such as latency and average cost.
     * Create DA dynamic data
     */
    async setDAInfoRaw(requestParameters: SetDAInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PostResponse>> {
        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling setDAInfo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/info/da`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DAInfoResourceToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PostResponseFromJSON(jsonValue));
    }

    /**
     * Creates dynamic data for a specified Data Availability (DA) solution, including metrics such as latency and average cost.
     * Create DA dynamic data
     */
    async setDAInfo(requestParameters: SetDAInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PostResponse> {
        const response = await this.setDAInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stores dynamic data for Data Availability (DA), including latency, average cost, and other metrics.
     * Store DA dynamic data
     */
    async setNodeDAInfoRaw(requestParameters: SetNodeDAInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PostResponse>> {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError(
                'loginRequest',
                'Required parameter "loginRequest" was null or undefined when calling setNodeDAInfo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/node/info/da`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PostResponseFromJSON(jsonValue));
    }

    /**
     * Stores dynamic data for Data Availability (DA), including latency, average cost, and other metrics.
     * Store DA dynamic data
     */
    async setNodeDAInfo(requestParameters: SetNodeDAInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PostResponse> {
        const response = await this.setNodeDAInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds a new proposal to the database.
     * Create a new proposal
     */
    async setProposalRaw(requestParameters: SetProposalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Proposal>> {
        if (requestParameters['proposal'] == null) {
            throw new runtime.RequiredError(
                'proposal',
                'Required parameter "proposal" was null or undefined when calling setProposal().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/proposals`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProposalToJSON(requestParameters['proposal']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProposalFromJSON(jsonValue));
    }

    /**
     * Adds a new proposal to the database.
     * Create a new proposal
     */
    async setProposal(requestParameters: SetProposalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Proposal> {
        const response = await this.setProposalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds a wallet address to the whitelist.
     * Add an address to the whitelist
     */
    async setWhiteListRaw(requestParameters: SetWhiteListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WhiteList>> {
        if (requestParameters['whiteList'] == null) {
            throw new runtime.RequiredError(
                'whiteList',
                'Required parameter "whiteList" was null or undefined when calling setWhiteList().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/whitelist`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WhiteListToJSON(requestParameters['whiteList']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WhiteListFromJSON(jsonValue));
    }

    /**
     * Adds a wallet address to the whitelist.
     * Add an address to the whitelist
     */
    async setWhiteList(requestParameters: SetWhiteListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WhiteList> {
        const response = await this.setWhiteListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the information of a specific quest.
     * Update quest details
     */
    async updateQuestsRaw(requestParameters: UpdateQuestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Quests>> {
        if (requestParameters['questId'] == null) {
            throw new runtime.RequiredError(
                'questId',
                'Required parameter "questId" was null or undefined when calling updateQuests().'
            );
        }

        if (requestParameters['quests'] == null) {
            throw new runtime.RequiredError(
                'quests',
                'Required parameter "quests" was null or undefined when calling updateQuests().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/quests/{quest_id}`.replace(`{${"quest_id"}}`, encodeURIComponent(String(requestParameters['questId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: QuestsToJSON(requestParameters['quests']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestsFromJSON(jsonValue));
    }

    /**
     * Updates the information of a specific quest.
     * Update quest details
     */
    async updateQuests(requestParameters: UpdateQuestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Quests> {
        const response = await this.updateQuestsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the status of a specific worker deployment.
     * Update worker deployment status
     */
    async updateWorkerDeploymentRaw(requestParameters: UpdateWorkerDeploymentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Deployment>> {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError(
                'loginRequest',
                'Required parameter "loginRequest" was null or undefined when calling updateWorkerDeployment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/deployments/worker/status`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeploymentFromJSON(jsonValue));
    }

    /**
     * Updates the status of a specific worker deployment.
     * Update worker deployment status
     */
    async updateWorkerDeployment(requestParameters: UpdateWorkerDeploymentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Deployment> {
        const response = await this.updateWorkerDeploymentRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetDAsNameEnum = {
    All: 'all',
    EigenDa: 'EigenDA',
    NearDa: 'NearDA',
    Celestia: 'Celestia',
    Avail: 'Avail',
    Ethereum: 'Ethereum',
    _0g: '0g'
} as const;
export type GetDAsNameEnum = typeof GetDAsNameEnum[keyof typeof GetDAsNameEnum];
/**
 * @export
 */
export const GetDAsNetworkTypeEnum = {
    Mainnet: 'Mainnet',
    Testnet: 'Testnet'
} as const;
export type GetDAsNetworkTypeEnum = typeof GetDAsNetworkTypeEnum[keyof typeof GetDAsNetworkTypeEnum];
/**
 * @export
 */
export const GetDAsTemporaryNameEnum = {
    All: 'all',
    EigenDa: 'EigenDA',
    NearDa: 'NearDA',
    Celestia: 'Celestia',
    Avail: 'Avail',
    Ethereum: 'Ethereum',
    _0g: '0g'
} as const;
export type GetDAsTemporaryNameEnum = typeof GetDAsTemporaryNameEnum[keyof typeof GetDAsTemporaryNameEnum];
/**
 * @export
 */
export const GetDAsTemporaryNetworkTypeEnum = {
    Mainnet: 'Mainnet',
    Testnet: 'Testnet'
} as const;
export type GetDAsTemporaryNetworkTypeEnum = typeof GetDAsTemporaryNetworkTypeEnum[keyof typeof GetDAsTemporaryNetworkTypeEnum];
/**
 * @export
 */
export const GraphDAInfoEndPointNetworkTypeEnum = {
    Mainnet: 'Mainnet',
    Testnet: 'Testnet'
} as const;
export type GraphDAInfoEndPointNetworkTypeEnum = typeof GraphDAInfoEndPointNetworkTypeEnum[keyof typeof GraphDAInfoEndPointNetworkTypeEnum];
/**
 * @export
 */
export const GraphDAInfoEndPointDaListEnum = {
    EigenDa: 'EigenDA',
    NearDa: 'NearDA',
    Celestia: 'Celestia',
    Avail: 'Avail',
    Ethereum: 'Ethereum',
    _0g: '0g',
    All: 'all'
} as const;
export type GraphDAInfoEndPointDaListEnum = typeof GraphDAInfoEndPointDaListEnum[keyof typeof GraphDAInfoEndPointDaListEnum];
/**
 * @export
 */
export const InteractTypeEnum = {
    InteractWithDashboard: 'interact_with_dashboard',
    UseDeployedBlueprintProposal: 'use_deployed_blueprint_proposal'
} as const;
export type InteractTypeEnum = typeof InteractTypeEnum[keyof typeof InteractTypeEnum];
/**
 * @export
 */
export const ListDAInfoNameEnum = {
    All: 'all',
    EigenDa: 'EigenDA',
    NearDa: 'NearDA',
    Celestia: 'Celestia',
    Avail: 'Avail',
    Ethereum: 'Ethereum',
    _0g: '0g'
} as const;
export type ListDAInfoNameEnum = typeof ListDAInfoNameEnum[keyof typeof ListDAInfoNameEnum];
/**
 * @export
 */
export const ListDAInfoNetworkTypeEnum = {
    Mainnet: 'Mainnet',
    Testnet: 'Testnet'
} as const;
export type ListDAInfoNetworkTypeEnum = typeof ListDAInfoNetworkTypeEnum[keyof typeof ListDAInfoNetworkTypeEnum];

/* tslint:disable */
/* eslint-disable */
/**
 * Crestal dashboard API - /crestal - OpenAPI 3.0
 * This is a crestal-dashboard-backend server.
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import * as runtime from '../runtime';
import { APIKeyFromJSON, ChatFromJSON, ChatRequestToJSON, CommonResponseFromJSON, DAFromJSON, DAToJSON, DAInfoResourceToJSON, DeploymentFromJSON, DeploymentToJSON, DeploymentsFromJSON, GetNonce200ResponseFromJSON, GraphDAInfoResponseFromJSON, ListDAInfoResponseFromJSON, LoginRequestToJSON, LoginResponseFromJSON, PostResponseFromJSON, ProjectResourceFromJSON, ProjectUpdateToJSON, ProjectsFromJSON, ProposalFromJSON, ProposalToJSON, QuestsFromJSON, QuestsToJSON, ReferralFromJSON, ScoreFromJSON, SolverFromJSON, SolverToJSON, SolverProposalsFromJSON, SolversProposalsFromJSON, SolversProposalsResponseFromJSON, TokenFromJSON, UserFromJSON, UserPostQuestsToJSON, UserQuestFromJSON, WeeklyQuestsFromJSON, WhiteListFromJSON, WhiteListToJSON, WorkerFromJSON, } from '../models/index';
/**
 *
 */
export class DefaultApi extends runtime.BaseAPI {
    /**
     * Provides an API key associated with the specified user address.
     * Retrieve an API key
     */
    async aPIKeyRaw(requestParameters, initOverrides) {
        if (requestParameters['userAddress'] == null) {
            throw new runtime.RequiredError('userAddress', 'Required parameter "userAddress" was null or undefined when calling aPIKey().');
        }
        const queryParameters = {};
        if (requestParameters['userAddress'] != null) {
            queryParameters['user_address'] = requestParameters['userAddress'];
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/api_key`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => APIKeyFromJSON(jsonValue));
    }
    /**
     * Provides an API key associated with the specified user address.
     * Retrieve an API key
     */
    async aPIKey(requestParameters, initOverrides) {
        const response = await this.aPIKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Accepts a list of proposals from solvers for processing.
     * Accept a list of proposals from solvers
     */
    async acceptSolverProposalsRaw(requestParameters, initOverrides) {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError('loginRequest', 'Required parameter "loginRequest" was null or undefined when calling acceptSolverProposals().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/proposals/solver`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => SolversProposalsFromJSON(jsonValue));
    }
    /**
     * Accepts a list of proposals from solvers for processing.
     * Accept a list of proposals from solvers
     */
    async acceptSolverProposals(requestParameters, initOverrides) {
        const response = await this.acceptSolverProposalsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Claims a specific referral code.
     * Claim a referral code
     */
    async claimReferCodeRaw(requestParameters, initOverrides) {
        if (requestParameters['code'] == null) {
            throw new runtime.RequiredError('code', 'Required parameter "code" was null or undefined when calling claimReferCode().');
        }
        const queryParameters = {};
        if (requestParameters['isClaimed'] != null) {
            queryParameters['is_claimed'] = requestParameters['isClaimed'];
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/referral/{code}/claim`.replace(`{${"code"}}`, encodeURIComponent(String(requestParameters['code']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => CommonResponseFromJSON(jsonValue));
    }
    /**
     * Claims a specific referral code.
     * Claim a referral code
     */
    async claimReferCode(requestParameters, initOverrides) {
        const response = await this.claimReferCodeRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Generates a new API key for the specified user.
     * Create a new API key
     */
    async createAPIKeyRaw(requestParameters, initOverrides) {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError('loginRequest', 'Required parameter "loginRequest" was null or undefined when calling createAPIKey().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/api_key`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => APIKeyFromJSON(jsonValue));
    }
    /**
     * Generates a new API key for the specified user.
     * Create a new API key
     */
    async createAPIKey(requestParameters, initOverrides) {
        const response = await this.createAPIKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Onboards a new Data Availability (DA) solution, including static information such as consensus algorithm.
     * Create a new DA entry in the database
     */
    async createDARaw(requestParameters, initOverrides) {
        if (requestParameters['dA'] == null) {
            throw new runtime.RequiredError('dA', 'Required parameter "dA" was null or undefined when calling createDA().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/onboarding/da`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DAToJSON(requestParameters['dA']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => DAFromJSON(jsonValue));
    }
    /**
     * Onboards a new Data Availability (DA) solution, including static information such as consensus algorithm.
     * Create a new DA entry in the database
     */
    async createDA(requestParameters, initOverrides) {
        const response = await this.createDARaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Adds a new quest to the system.
     * Create a new quest
     */
    async createQuestsRaw(requestParameters, initOverrides) {
        if (requestParameters['quests'] == null) {
            throw new runtime.RequiredError('quests', 'Required parameter "quests" was null or undefined when calling createQuests().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/quests`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QuestsToJSON(requestParameters['quests']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => QuestsFromJSON(jsonValue));
    }
    /**
     * Adds a new quest to the system.
     * Create a new quest
     */
    async createQuests(requestParameters, initOverrides) {
        const response = await this.createQuestsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Adds a new solver with provided details.
     * Create a solver
     */
    async createSolverRaw(requestParameters, initOverrides) {
        if (requestParameters['solver'] == null) {
            throw new runtime.RequiredError('solver', 'Required parameter "solver" was null or undefined when calling createSolver().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/solvers`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SolverToJSON(requestParameters['solver']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => SolverFromJSON(jsonValue));
    }
    /**
     * Adds a new solver with provided details.
     * Create a solver
     */
    async createSolver(requestParameters, initOverrides) {
        const response = await this.createSolverRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Creates deployment information for a specific worker.
     * Create worker deployment information
     */
    async createWorkerDeploymentRaw(requestParameters, initOverrides) {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError('loginRequest', 'Required parameter "loginRequest" was null or undefined when calling createWorkerDeployment().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/deployments/worker`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => DeploymentFromJSON(jsonValue));
    }
    /**
     * Creates deployment information for a specific worker.
     * Create worker deployment information
     */
    async createWorkerDeployment(requestParameters, initOverrides) {
        const response = await this.createWorkerDeploymentRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Creates new deployment information for a specified user or proposal.
     * Create deployment information
     */
    async deploymentPostRaw(requestParameters, initOverrides) {
        if (requestParameters['deployment'] == null) {
            throw new runtime.RequiredError('deployment', 'Required parameter "deployment" was null or undefined when calling deploymentPost().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/deployments`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DeploymentToJSON(requestParameters['deployment']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => DeploymentFromJSON(jsonValue));
    }
    /**
     * Creates new deployment information for a specified user or proposal.
     * Create deployment information
     */
    async deploymentPost(requestParameters, initOverrides) {
        const response = await this.deploymentPostRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the chat history associated with a specified project.
     * Retrieve chat history
     */
    async getChatRaw(requestParameters, initOverrides) {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError('projectId', 'Required parameter "projectId" was null or undefined when calling getChat().');
        }
        const queryParameters = {};
        if (requestParameters['projectId'] != null) {
            queryParameters['project_id'] = requestParameters['projectId'];
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/chat`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ChatFromJSON));
    }
    /**
     * Retrieves the chat history associated with a specified project.
     * Retrieve chat history
     */
    async getChat(requestParameters, initOverrides) {
        const response = await this.getChatRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Provides static information for specified Data Availability (DA) solutions.
     * Retrieve DA static information
     */
    async getDAsRaw(requestParameters, initOverrides) {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError('name', 'Required parameter "name" was null or undefined when calling getDAs().');
        }
        const queryParameters = {};
        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }
        if (requestParameters['networkType'] != null) {
            queryParameters['network_type'] = requestParameters['networkType'];
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/info/da/static`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => DAFromJSON(jsonValue));
    }
    /**
     * Provides static information for specified Data Availability (DA) solutions.
     * Retrieve DA static information
     */
    async getDAs(requestParameters, initOverrides) {
        const response = await this.getDAsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Provides static information about a specific Data Availability (DA) solution. This endpoint is temporary and will be removed later.
     * Retrieve DA static information (temporary endpoint)
     */
    async getDAsTemporaryRaw(requestParameters, initOverrides) {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError('name', 'Required parameter "name" was null or undefined when calling getDAsTemporary().');
        }
        const queryParameters = {};
        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }
        if (requestParameters['networkType'] != null) {
            queryParameters['network_type'] = requestParameters['networkType'];
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/das`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => DAFromJSON(jsonValue));
    }
    /**
     * Provides static information about a specific Data Availability (DA) solution. This endpoint is temporary and will be removed later.
     * Retrieve DA static information (temporary endpoint)
     */
    async getDAsTemporary(requestParameters, initOverrides) {
        const response = await this.getDAsTemporaryRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Fetches detailed information about a deployment by its unique identifier.
     * Retrieve deployment information
     */
    async getDeploymentByIdRaw(requestParameters, initOverrides) {
        if (requestParameters['deploymentId'] == null) {
            throw new runtime.RequiredError('deploymentId', 'Required parameter "deploymentId" was null or undefined when calling getDeploymentById().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/deployments/{deployment_id}`.replace(`{${"deployment_id"}}`, encodeURIComponent(String(requestParameters['deploymentId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => DeploymentFromJSON(jsonValue));
    }
    /**
     * Fetches detailed information about a deployment by its unique identifier.
     * Retrieve deployment information
     */
    async getDeploymentById(requestParameters, initOverrides) {
        const response = await this.getDeploymentByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Provides a list of all deployment information associated with the user\'s address, proposal ID, or hash.
     * Retrieve deployments based on various parameters
     */
    async getDeploymentsRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters['userAddress'] != null) {
            queryParameters['user_address'] = requestParameters['userAddress'];
        }
        if (requestParameters['proposalId'] != null) {
            queryParameters['proposal_id'] = requestParameters['proposalId'];
        }
        if (requestParameters['proposalHash'] != null) {
            queryParameters['proposal_hash'] = requestParameters['proposalHash'];
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/deployments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => DeploymentsFromJSON(jsonValue));
    }
    /**
     * Provides a list of all deployment information associated with the user\'s address, proposal ID, or hash.
     * Retrieve deployments based on various parameters
     */
    async getDeployments(requestParameters = {}, initOverrides) {
        const response = await this.getDeploymentsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Provides a nonce for authentication purposes..
     * Retrieve nonce for authentication
     */
    async getNonceRaw(requestParameters, initOverrides) {
        if (requestParameters['userAddress'] == null) {
            throw new runtime.RequiredError('userAddress', 'Required parameter "userAddress" was null or undefined when calling getNonce().');
        }
        const queryParameters = {};
        if (requestParameters['userAddress'] != null) {
            queryParameters['user_address'] = requestParameters['userAddress'];
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/nonce`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => GetNonce200ResponseFromJSON(jsonValue));
    }
    /**
     * Provides a nonce for authentication purposes..
     * Retrieve nonce for authentication
     */
    async getNonce(requestParameters, initOverrides) {
        const response = await this.getNonceRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Provides detailed information about the projects associated with the user\'s address.
     * Retrieve a list of user projects
     */
    async getProjectStatusRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters['userAddress'] != null) {
            queryParameters['user_address'] = requestParameters['userAddress'];
        }
        if (requestParameters['proposalId'] != null) {
            queryParameters['proposal_id'] = requestParameters['proposalId'];
        }
        if (requestParameters['deploymentId'] != null) {
            queryParameters['deployment_id'] = requestParameters['deploymentId'];
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectsFromJSON(jsonValue));
    }
    /**
     * Provides detailed information about the projects associated with the user\'s address.
     * Retrieve a list of user projects
     */
    async getProjectStatus(requestParameters = {}, initOverrides) {
        const response = await this.getProjectStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Fetches detailed information about the specified project.
     * Retrieve project information
     */
    async getProjectStatusByIdRaw(requestParameters, initOverrides) {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError('projectId', 'Required parameter "projectId" was null or undefined when calling getProjectStatusById().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{project_id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectResourceFromJSON(jsonValue));
    }
    /**
     * Fetches detailed information about the specified project.
     * Retrieve project information
     */
    async getProjectStatusById(requestParameters, initOverrides) {
        const response = await this.getProjectStatusByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Provides detailed information about a proposal by its unique identifier.
     * Retrieve a proposal by ID
     */
    async getProposalByIDRaw(requestParameters, initOverrides) {
        if (requestParameters['proposalId'] == null) {
            throw new runtime.RequiredError('proposalId', 'Required parameter "proposalId" was null or undefined when calling getProposalByID().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/proposals/{proposal_id}`.replace(`{${"proposal_id"}}`, encodeURIComponent(String(requestParameters['proposalId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => ProposalFromJSON(jsonValue));
    }
    /**
     * Provides detailed information about a proposal by its unique identifier.
     * Retrieve a proposal by ID
     */
    async getProposalByID(requestParameters, initOverrides) {
        const response = await this.getProposalByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Provides a list of all quests available to the user.
     * Retrieve all quests
     */
    async getQuestsRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/quests`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(QuestsFromJSON));
    }
    /**
     * Provides a list of all quests available to the user.
     * Retrieve all quests
     */
    async getQuests(initOverrides) {
        const response = await this.getQuestsRaw(initOverrides);
        return await response.value();
    }
    /**
     * Provides a list of proposals recommended by solvers. The list is sorted by default.
     * Retrieve recommended proposals from solvers
     */
    async getRecommendProposalsRaw(requestParameters, initOverrides) {
        if (requestParameters['sla'] == null) {
            throw new runtime.RequiredError('sla', 'Required parameter "sla" was null or undefined when calling getRecommendProposals().');
        }
        if (requestParameters['cost'] == null) {
            throw new runtime.RequiredError('cost', 'Required parameter "cost" was null or undefined when calling getRecommendProposals().');
        }
        if (requestParameters['throughput'] == null) {
            throw new runtime.RequiredError('throughput', 'Required parameter "throughput" was null or undefined when calling getRecommendProposals().');
        }
        if (requestParameters['errorRate'] == null) {
            throw new runtime.RequiredError('errorRate', 'Required parameter "errorRate" was null or undefined when calling getRecommendProposals().');
        }
        const queryParameters = {};
        if (requestParameters['sla'] != null) {
            queryParameters['sla'] = requestParameters['sla'];
        }
        if (requestParameters['cost'] != null) {
            queryParameters['cost'] = requestParameters['cost'];
        }
        if (requestParameters['throughput'] != null) {
            queryParameters['throughput'] = requestParameters['throughput'];
        }
        if (requestParameters['errorRate'] != null) {
            queryParameters['error_rate'] = requestParameters['errorRate'];
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/proposals/recommendation`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => SolverProposalsFromJSON(jsonValue));
    }
    /**
     * Provides a list of proposals recommended by solvers. The list is sorted by default.
     * Retrieve recommended proposals from solvers
     */
    async getRecommendProposals(requestParameters, initOverrides) {
        const response = await this.getRecommendProposalsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the top scores for a specified number of users.
     * Retrieve top user scores
     */
    async getScoresRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters['topK'] != null) {
            queryParameters['top_k'] = requestParameters['topK'];
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/scores`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ScoreFromJSON));
    }
    /**
     * Retrieves the top scores for a specified number of users.
     * Retrieve top user scores
     */
    async getScores(requestParameters = {}, initOverrides) {
        const response = await this.getScoresRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Provides information for a solver identified by a UUID.
     * Retrieve solver details by UUID
     */
    async getSolverByUUIDRaw(requestParameters, initOverrides) {
        if (requestParameters['solverUuid'] == null) {
            throw new runtime.RequiredError('solverUuid', 'Required parameter "solverUuid" was null or undefined when calling getSolverByUUID().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/solvers/{solver_uuid}`.replace(`{${"solver_uuid"}}`, encodeURIComponent(String(requestParameters['solverUuid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => SolverFromJSON(jsonValue));
    }
    /**
     * Provides information for a solver identified by a UUID.
     * Retrieve solver details by UUID
     */
    async getSolverByUUID(requestParameters, initOverrides) {
        const response = await this.getSolverByUUIDRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Provides recommended proposals generated by solvers.
     * Retrieve recommended proposals from solvers
     */
    async getSolversProposalsRaw(requestParameters, initOverrides) {
        if (requestParameters['requestId'] == null) {
            throw new runtime.RequiredError('requestId', 'Required parameter "requestId" was null or undefined when calling getSolversProposals().');
        }
        const queryParameters = {};
        if (requestParameters['requestId'] != null) {
            queryParameters['request_id'] = requestParameters['requestId'];
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/proposals/solver`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => SolversProposalsResponseFromJSON(jsonValue));
    }
    /**
     * Provides recommended proposals generated by solvers.
     * Retrieve recommended proposals from solvers
     */
    async getSolversProposals(requestParameters, initOverrides) {
        const response = await this.getSolversProposalsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Fetches information for a specific user by their blockchain address.
     * Retrieve user information
     */
    async getUserInfoRaw(requestParameters, initOverrides) {
        if (requestParameters['userAddress'] == null) {
            throw new runtime.RequiredError('userAddress', 'Required parameter "userAddress" was null or undefined when calling getUserInfo().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/users/{user_address}`.replace(`{${"user_address"}}`, encodeURIComponent(String(requestParameters['userAddress']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }
    /**
     * Fetches information for a specific user by their blockchain address.
     * Retrieve user information
     */
    async getUserInfo(requestParameters, initOverrides) {
        const response = await this.getUserInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Provides a list of all quests associated with a user.
     * Retrieve all user quests
     */
    async getUserQuestsRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/user/quests`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserQuestFromJSON));
    }
    /**
     * Provides a list of all quests associated with a user.
     * Retrieve all user quests
     */
    async getUserQuests(initOverrides) {
        const response = await this.getUserQuestsRaw(initOverrides);
        return await response.value();
    }
    /**
     * Retrieves referral details for the user, including the referral code, creation time, and claim status.
     * Retrieve user referral information
     */
    async getUserReferralRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/referral`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ReferralFromJSON));
    }
    /**
     * Retrieves referral details for the user, including the referral code, creation time, and claim status.
     * Retrieve user referral information
     */
    async getUserReferral(initOverrides) {
        const response = await this.getUserReferralRaw(initOverrides);
        return await response.value();
    }
    /**
     * Retrieves a list of weekly quests available for all users.
     * Retrieve weekly quests for all users
     */
    async getWeeklyQuestsRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/quests/weekly`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => WeeklyQuestsFromJSON(jsonValue));
    }
    /**
     * Retrieves a list of weekly quests available for all users.
     * Retrieve weekly quests for all users
     */
    async getWeeklyQuests(initOverrides) {
        const response = await this.getWeeklyQuestsRaw(initOverrides);
        return await response.value();
    }
    /**
     * Provides a list of all wallet addresses that have been whitelisted.
     * Retrieve all whitelisted wallet addresses
     */
    async getWhiteListsRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/whitelist`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WhiteListFromJSON));
    }
    /**
     * Provides a list of all wallet addresses that have been whitelisted.
     * Retrieve all whitelisted wallet addresses
     */
    async getWhiteLists(initOverrides) {
        const response = await this.getWhiteListsRaw(initOverrides);
        return await response.value();
    }
    /**
     * Provides information for a worker identified by a UUID.
     * Retrieve worker details by UUID
     */
    async getWorkerByUUIDRaw(requestParameters, initOverrides) {
        if (requestParameters['workerUuid'] == null) {
            throw new runtime.RequiredError('workerUuid', 'Required parameter "workerUuid" was null or undefined when calling getWorkerByUUID().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/workers/{worker_uuid}`.replace(`{${"worker_uuid"}}`, encodeURIComponent(String(requestParameters['workerUuid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => WorkerFromJSON(jsonValue));
    }
    /**
     * Provides information for a worker identified by a UUID.
     * Retrieve worker details by UUID
     */
    async getWorkerByUUID(requestParameters, initOverrides) {
        const response = await this.getWorkerByUUIDRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Provides deployment information associated with a specific request ID.
     * Retrieve worker deployments by request ID
     */
    async getWorkerDeploymentsRaw(requestParameters, initOverrides) {
        if (requestParameters['requestId'] == null) {
            throw new runtime.RequiredError('requestId', 'Required parameter "requestId" was null or undefined when calling getWorkerDeployments().');
        }
        const queryParameters = {};
        if (requestParameters['requestId'] != null) {
            queryParameters['request_id'] = requestParameters['requestId'];
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/deployments/worker`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => DeploymentFromJSON(jsonValue));
    }
    /**
     * Provides deployment information associated with a specific request ID.
     * Retrieve worker deployments by request ID
     */
    async getWorkerDeployments(requestParameters, initOverrides) {
        const response = await this.getWorkerDeploymentsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Provides a list of all workers.
     * Retrieve a list of workers
     */
    async getWorkersRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/workers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkerFromJSON));
    }
    /**
     * Provides a list of all workers.
     * Retrieve a list of workers
     */
    async getWorkers(initOverrides) {
        const response = await this.getWorkersRaw(initOverrides);
        return await response.value();
    }
    /**
     * Provides a list of graph data for Data Availability (DA) solutions, including metrics such as latency and average cost.
     * Retrieve DA graph information
     */
    async graphDAInfoEndPointRaw(requestParameters, initOverrides) {
        if (requestParameters['fromTime'] == null) {
            throw new runtime.RequiredError('fromTime', 'Required parameter "fromTime" was null or undefined when calling graphDAInfoEndPoint().');
        }
        if (requestParameters['toTime'] == null) {
            throw new runtime.RequiredError('toTime', 'Required parameter "toTime" was null or undefined when calling graphDAInfoEndPoint().');
        }
        if (requestParameters['networkType'] == null) {
            throw new runtime.RequiredError('networkType', 'Required parameter "networkType" was null or undefined when calling graphDAInfoEndPoint().');
        }
        if (requestParameters['daList'] == null) {
            throw new runtime.RequiredError('daList', 'Required parameter "daList" was null or undefined when calling graphDAInfoEndPoint().');
        }
        const queryParameters = {};
        if (requestParameters['fromTime'] != null) {
            queryParameters['from_time'] = requestParameters['fromTime'];
        }
        if (requestParameters['toTime'] != null) {
            queryParameters['to_time'] = requestParameters['toTime'];
        }
        if (requestParameters['networkType'] != null) {
            queryParameters['network_type'] = requestParameters['networkType'];
        }
        if (requestParameters['daList'] != null) {
            queryParameters['da_list'] = requestParameters['daList'].join(runtime.COLLECTION_FORMATS["csv"]);
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/info/da/graph`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => GraphDAInfoResponseFromJSON(jsonValue));
    }
    /**
     * Provides a list of graph data for Data Availability (DA) solutions, including metrics such as latency and average cost.
     * Retrieve DA graph information
     */
    async graphDAInfoEndPoint(requestParameters, initOverrides) {
        const response = await this.graphDAInfoEndPointRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async healthCheckGetRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/health_check`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     */
    async healthCheckGet(initOverrides) {
        await this.healthCheckGetRaw(initOverrides);
    }
    /**
     * Imports completed quests for a specific user.
     * Import user completed quests
     */
    async importUserQuestsRaw(requestParameters, initOverrides) {
        if (requestParameters['userPostQuests'] == null) {
            throw new runtime.RequiredError('userPostQuests', 'Required parameter "userPostQuests" was null or undefined when calling importUserQuests().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/user/quests`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserPostQuestsToJSON(requestParameters['userPostQuests']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => CommonResponseFromJSON(jsonValue));
    }
    /**
     * Imports completed quests for a specific user.
     * Import user completed quests
     */
    async importUserQuests(requestParameters, initOverrides) {
        const response = await this.importUserQuestsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Submit a report detailing interactions with the dashboard.
     * Submit interaction report
     */
    async interactRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters['userAddress'] != null) {
            queryParameters['user_address'] = requestParameters['userAddress'];
        }
        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/report`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * Submit a report detailing interactions with the dashboard.
     * Submit interaction report
     */
    async interact(requestParameters = {}, initOverrides) {
        await this.interactRaw(requestParameters, initOverrides);
    }
    /**
     * Retrieves a list of dynamic data for specified Data Availability (DA) solutions.
     * List Data Availability (DA) dynamic data
     */
    async listDAInfoRaw(requestParameters, initOverrides) {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError('name', 'Required parameter "name" was null or undefined when calling listDAInfo().');
        }
        if (requestParameters['networkType'] == null) {
            throw new runtime.RequiredError('networkType', 'Required parameter "networkType" was null or undefined when calling listDAInfo().');
        }
        const queryParameters = {};
        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }
        if (requestParameters['networkType'] != null) {
            queryParameters['network_type'] = requestParameters['networkType'];
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/info/da`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => ListDAInfoResponseFromJSON(jsonValue));
    }
    /**
     * Retrieves a list of dynamic data for specified Data Availability (DA) solutions.
     * List Data Availability (DA) dynamic data
     */
    async listDAInfo(requestParameters, initOverrides) {
        const response = await this.listDAInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Authenticates the user and sets a session cookie.
     * Authenticate and obtain session cookie
     */
    async loginRaw(requestParameters, initOverrides) {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError('loginRequest', 'Required parameter "loginRequest" was null or undefined when calling login().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/login`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => LoginResponseFromJSON(jsonValue));
    }
    /**
     * Authenticates the user and sets a session cookie.
     * Authenticate and obtain session cookie
     */
    async login(requestParameters, initOverrides) {
        const response = await this.loginRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Updates the status of the specified project to \"cancelled.\"
     * Cancel a project
     */
    async projectCancelledRaw(requestParameters, initOverrides) {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError('projectId', 'Required parameter "projectId" was null or undefined when calling projectCancelled().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{project_id}/cancelled`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectResourceFromJSON(jsonValue));
    }
    /**
     * Updates the status of the specified project to \"cancelled.\"
     * Cancel a project
     */
    async projectCancelled(requestParameters, initOverrides) {
        const response = await this.projectCancelledRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Updates the details of a specified project, primarily used to track user activity.
     * Update project information
     */
    async projectPatchRaw(requestParameters, initOverrides) {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError('projectId', 'Required parameter "projectId" was null or undefined when calling projectPatch().');
        }
        if (requestParameters['projectUpdate'] == null) {
            throw new runtime.RequiredError('projectUpdate', 'Required parameter "projectUpdate" was null or undefined when calling projectPatch().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{project_id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectUpdateToJSON(requestParameters['projectUpdate']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectResourceFromJSON(jsonValue));
    }
    /**
     * Updates the details of a specified project, primarily used to track user activity.
     * Update project information
     */
    async projectPatch(requestParameters, initOverrides) {
        const response = await this.projectPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Creates new project information, primarily used to track user activity in the frontend.
     * Create new project information
     */
    async projectPostRaw(requestParameters, initOverrides) {
        if (requestParameters['projectUpdate'] == null) {
            throw new runtime.RequiredError('projectUpdate', 'Required parameter "projectUpdate" was null or undefined when calling projectPost().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectUpdateToJSON(requestParameters['projectUpdate']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectResourceFromJSON(jsonValue));
    }
    /**
     * Creates new project information, primarily used to track user activity in the frontend.
     * Create new project information
     */
    async projectPost(requestParameters, initOverrides) {
        const response = await this.projectPostRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Updates the status of the specified project to \"terminated.\"
     * Terminate a project
     */
    async projectStopRaw(requestParameters, initOverrides) {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError('projectId', 'Required parameter "projectId" was null or undefined when calling projectStop().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{project_id}/stop`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectResourceFromJSON(jsonValue));
    }
    /**
     * Updates the status of the specified project to \"terminated.\"
     * Terminate a project
     */
    async projectStop(requestParameters, initOverrides) {
        const response = await this.projectStopRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Provides a new authentication token for the user.
     * Refresh authentication token
     */
    async refreshTokenRaw(requestParameters, initOverrides) {
        if (requestParameters['userAddress'] == null) {
            throw new runtime.RequiredError('userAddress', 'Required parameter "userAddress" was null or undefined when calling refreshToken().');
        }
        const queryParameters = {};
        if (requestParameters['userAddress'] != null) {
            queryParameters['user_address'] = requestParameters['userAddress'];
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/token`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
    }
    /**
     * Provides a new authentication token for the user.
     * Refresh authentication token
     */
    async refreshToken(requestParameters, initOverrides) {
        const response = await this.refreshTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Sends a chat message to the chat server.
     * Send a chat message
     */
    async sendChatRaw(requestParameters, initOverrides) {
        if (requestParameters['chatRequest'] == null) {
            throw new runtime.RequiredError('chatRequest', 'Required parameter "chatRequest" was null or undefined when calling sendChat().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/chat`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ChatRequestToJSON(requestParameters['chatRequest']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => ChatFromJSON(jsonValue));
    }
    /**
     * Sends a chat message to the chat server.
     * Send a chat message
     */
    async sendChat(requestParameters, initOverrides) {
        const response = await this.sendChatRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Creates dynamic data for a specified Data Availability (DA) solution, including metrics such as latency and average cost.
     * Create DA dynamic data
     */
    async setDAInfoRaw(requestParameters, initOverrides) {
        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError('data', 'Required parameter "data" was null or undefined when calling setDAInfo().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/info/da`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DAInfoResourceToJSON(requestParameters['data']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => PostResponseFromJSON(jsonValue));
    }
    /**
     * Creates dynamic data for a specified Data Availability (DA) solution, including metrics such as latency and average cost.
     * Create DA dynamic data
     */
    async setDAInfo(requestParameters, initOverrides) {
        const response = await this.setDAInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Stores dynamic data for Data Availability (DA), including latency, average cost, and other metrics.
     * Store DA dynamic data
     */
    async setNodeDAInfoRaw(requestParameters, initOverrides) {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError('loginRequest', 'Required parameter "loginRequest" was null or undefined when calling setNodeDAInfo().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/node/info/da`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => PostResponseFromJSON(jsonValue));
    }
    /**
     * Stores dynamic data for Data Availability (DA), including latency, average cost, and other metrics.
     * Store DA dynamic data
     */
    async setNodeDAInfo(requestParameters, initOverrides) {
        const response = await this.setNodeDAInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Adds a new proposal to the database.
     * Create a new proposal
     */
    async setProposalRaw(requestParameters, initOverrides) {
        if (requestParameters['proposal'] == null) {
            throw new runtime.RequiredError('proposal', 'Required parameter "proposal" was null or undefined when calling setProposal().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/proposals`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProposalToJSON(requestParameters['proposal']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => ProposalFromJSON(jsonValue));
    }
    /**
     * Adds a new proposal to the database.
     * Create a new proposal
     */
    async setProposal(requestParameters, initOverrides) {
        const response = await this.setProposalRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Adds a wallet address to the whitelist.
     * Add an address to the whitelist
     */
    async setWhiteListRaw(requestParameters, initOverrides) {
        if (requestParameters['whiteList'] == null) {
            throw new runtime.RequiredError('whiteList', 'Required parameter "whiteList" was null or undefined when calling setWhiteList().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/whitelist`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WhiteListToJSON(requestParameters['whiteList']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => WhiteListFromJSON(jsonValue));
    }
    /**
     * Adds a wallet address to the whitelist.
     * Add an address to the whitelist
     */
    async setWhiteList(requestParameters, initOverrides) {
        const response = await this.setWhiteListRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Updates the information of a specific quest.
     * Update quest details
     */
    async updateQuestsRaw(requestParameters, initOverrides) {
        if (requestParameters['questId'] == null) {
            throw new runtime.RequiredError('questId', 'Required parameter "questId" was null or undefined when calling updateQuests().');
        }
        if (requestParameters['quests'] == null) {
            throw new runtime.RequiredError('quests', 'Required parameter "quests" was null or undefined when calling updateQuests().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = await this.configuration.apiKey("X-Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/quests/{quest_id}`.replace(`{${"quest_id"}}`, encodeURIComponent(String(requestParameters['questId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: QuestsToJSON(requestParameters['quests']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => QuestsFromJSON(jsonValue));
    }
    /**
     * Updates the information of a specific quest.
     * Update quest details
     */
    async updateQuests(requestParameters, initOverrides) {
        const response = await this.updateQuestsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Updates the status of a specific worker deployment.
     * Update worker deployment status
     */
    async updateWorkerDeploymentRaw(requestParameters, initOverrides) {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError('loginRequest', 'Required parameter "loginRequest" was null or undefined when calling updateWorkerDeployment().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/deployments/worker/status`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => DeploymentFromJSON(jsonValue));
    }
    /**
     * Updates the status of a specific worker deployment.
     * Update worker deployment status
     */
    async updateWorkerDeployment(requestParameters, initOverrides) {
        const response = await this.updateWorkerDeploymentRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
/**
 * @export
 */
export const GetDAsNameEnum = {
    All: 'all',
    EigenDa: 'EigenDA',
    NearDa: 'NearDA',
    Celestia: 'Celestia',
    Avail: 'Avail',
    Ethereum: 'Ethereum',
    _0g: '0g'
};
/**
 * @export
 */
export const GetDAsNetworkTypeEnum = {
    Mainnet: 'Mainnet',
    Testnet: 'Testnet'
};
/**
 * @export
 */
export const GetDAsTemporaryNameEnum = {
    All: 'all',
    EigenDa: 'EigenDA',
    NearDa: 'NearDA',
    Celestia: 'Celestia',
    Avail: 'Avail',
    Ethereum: 'Ethereum',
    _0g: '0g'
};
/**
 * @export
 */
export const GetDAsTemporaryNetworkTypeEnum = {
    Mainnet: 'Mainnet',
    Testnet: 'Testnet'
};
/**
 * @export
 */
export const GraphDAInfoEndPointNetworkTypeEnum = {
    Mainnet: 'Mainnet',
    Testnet: 'Testnet'
};
/**
 * @export
 */
export const GraphDAInfoEndPointDaListEnum = {
    EigenDa: 'EigenDA',
    NearDa: 'NearDA',
    Celestia: 'Celestia',
    Avail: 'Avail',
    Ethereum: 'Ethereum',
    _0g: '0g',
    All: 'all'
};
/**
 * @export
 */
export const InteractTypeEnum = {
    InteractWithDashboard: 'interact_with_dashboard',
    UseDeployedBlueprintProposal: 'use_deployed_blueprint_proposal'
};
/**
 * @export
 */
export const ListDAInfoNameEnum = {
    All: 'all',
    EigenDa: 'EigenDA',
    NearDa: 'NearDA',
    Celestia: 'Celestia',
    Avail: 'Avail',
    Ethereum: 'Ethereum',
    _0g: '0g'
};
/**
 * @export
 */
export const ListDAInfoNetworkTypeEnum = {
    Mainnet: 'Mainnet',
    Testnet: 'Testnet'
};
